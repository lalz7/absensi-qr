{% extends "base.html" %}

{% block content %}
<style>
    /*
      CSS ini tetap sama. Efek cermin hanya akan aktif jika elemen video
      memiliki class 'mirrored'. Class ini akan kita tambahkan via JavaScript.
    */
    div#reader video.mirrored {
        transform: scaleX(-1);
    }
</style>

<div class="d-flex align-items-center justify-content-center min-vh-100 p-4">
    <div class="w-100" style="max-width: 400px;">
        <div class="card shadow-lg p-4 text-center">
            <h3 class="card-title text-2xl font-semibold mb-2">Absensi QR</h3>
            <p class="text-sm text-muted mb-4">Arahkan kamera ke QR Code siswa atau pegawai.</p>

            <div id="reader" class="w-100 rounded-lg overflow-hidden mb-4"></div>

            <div id="message-box" class="d-none min-h-12 w-100 p-3 font-semibold rounded-lg d-flex align-items-center justify-content-center transition-all duration-300"></div>

            <div id="loading-spinner" class="d-none my-4">
                <div class="spinner-border text-primary" role="status">
                    <span class="sr-only">Loading...</span>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

<script>
    // Inisialisasi elemen-elemen DOM
    const messageBox = document.getElementById('message-box');
    const loadingSpinner = document.getElementById('loading-spinner');
    const readerElement = document.getElementById('reader');

    /**
     * Fungsi untuk menerapkan efek cermin jika kamera depan aktif.
     * @param {HTMLVideoElement} videoElement - Elemen video yang sedang aktif.
     */
    const applyMirrorEffect = (videoElement) => {
        // Pastikan video stream sudah berjalan
        if (!videoElement || !videoElement.srcObject) return;

        const tracks = videoElement.srcObject.getVideoTracks();
        if (tracks.length > 0) {
            const settings = tracks[0].getSettings();
            // 'facingMode' akan bernilai 'user' untuk kamera depan
            if (settings.facingMode === 'user') {
                videoElement.classList.add('mirrored');
            } else {
                videoElement.classList.remove('mirrored');
            }
        }
    };

    // =========================================================================
    // SOLUSI BARU YANG LEBIH ANDAL
    // Kita gunakan MutationObserver untuk "mendengar" kapan library scanner
    // menambahkan elemen <video> ke dalam <div> #reader.
    // =========================================================================
    const observer = new MutationObserver((mutationsList) => {
        for (const mutation of mutationsList) {
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach(node => {
                    // Cari elemen video yang baru ditambahkan
                    const videoElement = node.querySelector('video') || (node.tagName === 'VIDEO' ? node : null);

                    if (videoElement) {
                        // Tambahkan event listener 'loadedmetadata'.
                        // Event ini hanya akan aktif setelah stream kamera siap,
                        // sehingga kita bisa mendapatkan info facingMode dengan akurat.
                        videoElement.addEventListener('loadedmetadata', () => {
                            applyMirrorEffect(videoElement);
                        });
                    }
                });
            }
        }
    });

    // Mulai mengamati elemen #reader untuk perubahan
    observer.observe(readerElement, { childList: true, subtree: true });


    // Inisialisasi scanner seperti biasa
    const html5QrcodeScanner = new Html5QrcodeScanner(
        "reader", {
            fps: 10,
            qrbox: { width: 250, height: 250 },
            rememberLastUsedCamera: true
        },
        false
    );

    function showMessage(type, message) {
        messageBox.classList.remove('bg-success-subtle', 'text-success', 'bg-danger-subtle', 'text-danger', 'bg-warning-subtle', 'text-warning', 'd-none');
        let colorClass = type === 'success' ? 'bg-success-subtle text-success' :
                         type === 'danger' ? 'bg-danger-subtle text-danger' :
                         'bg-warning-subtle text-warning';
        messageBox.className = `min-h-12 w-100 p-3 fw-bold rounded-lg d-flex align-items-center justify-content-center ${colorClass}`;
        messageBox.textContent = message;
    }

    async function onScanSuccess(decodedText) {
        html5QrcodeScanner.pause();
        messageBox.classList.add('d-none');
        loadingSpinner.classList.remove('d-none');

        try {
            const res = await fetch("/scan/submit_scan", {
                method: "POST",
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `identifier=${encodeURIComponent(decodedText)}`
            });
            const data = await res.json();
            showMessage(data.status, data.message);
        } catch (error) {
            console.error('Error:', error);
            showMessage('danger', 'Terjadi kesalahan jaringan atau server.');
        } finally {
            loadingSpinner.classList.add('d-none');
            setTimeout(() => {
                messageBox.classList.add('d-none');
                if (html5QrcodeScanner.getState() === 2) { // 2 = PAUSED
                    html5QrcodeScanner.resume();
                }
            }, 3000);
        }
    }

    function onScanFailure(error) {
        // Biarkan kosong
    }

    // Render pemindai QR Code
    html5QrcodeScanner.render(onScanSuccess, onScanFailure);
</script>
{% endblock %}